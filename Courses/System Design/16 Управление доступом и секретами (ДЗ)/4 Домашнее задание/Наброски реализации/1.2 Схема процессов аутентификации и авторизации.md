Хорошо, вот схема процессов аутентификации и авторизации для вашего стека (.NET Aspire, Keycloak, Vault):

```plantuml
@startuml
' Стили
skinparam sequence {
    arrowColor #666666
    actorLineColor #666666
    lifeLineBorderColor #666666
    lifeLineBackgroundColor #ffffff
}
skinparam note {
    borderColor #cccccc
    backgroundColor #ffffcc
}

title Схема процессов аутентификации и авторизации

actor "Пользователь" as user #e1f5fe
participant "Frontend\n(Aspire App)" as frontend #c8e6c9
participant "Keycloak\n(Auth Server)" as keycloak #e1bee7
participant "Backend API\n(Aspire Service)" as backend #e8f5e8
participant "HashiCorp Vault\n(Secrets)" as vault #ffe0b2
participant "PostgreSQL\n(Database)" as db #b2dfdb

== 1. Аутентификация пользователя (Authorization Code Flow) ==

user -> frontend : 1. Запрос доступа\nк защищенному ресурсу
frontend -> keycloak : 2. Перенаправление на\nKeycloak (Auth Code Flow)\n(запрос: client_id, redirect_uri,\nresponse_type=code, scope)
keycloak -> user : 3. Отображение формы\nлогина Keycloak
user -> keycloak : 4. Ввод учетных данных\n(логин/пароль)
keycloak -> user : 5. (Опционально) MFA\n(многофакторная аутентификация)
keycloak -> user : 6. Страница согласия\n(разрешения для приложения)
user -> keycloak : 7. Подтверждение согласия
keycloak -> frontend : 8. Перенаправление обратно\nс Authorization Code\n(redirect_uri?code=AUTH_CODE)

== 2. Получение токенов ==

frontend -> keycloak : 9. Запрос токенов по коду\n(POST /token)\n(grant_type=authorization_code,\ncode=AUTH_CODE, redirect_uri,\nclient_id, client_secret)
keycloak -> keycloak : 10. Проверка кода,\nгенерация токенов
keycloak -> frontend : 11. Возврат токенов\n(ID Token, Access Token [JWT], Refresh Token)

note right of keycloak
Access Token (JWT) содержит:
- sub (идентификатор пользователя)
- realm_access.roles: ["USER", "ADMIN"]
- resource_access.{client_id}.roles: ["special_role"]
- exp (срок действия)
- и другие claims
end note

== 3. Авторизация в Backend API ==

user -> frontend : 12. Вызов функции,\nтребующей API
frontend -> backend : 13. Вызов Backend API\nс Access Token\n(Authorization: Bearer <JWT>)
backend -> keycloak : 14. (Периодически) Получение\nпубличного ключа JWKS\n(GET /.well-known/openid-configuration/jwks)
backend -> backend : 15. Проверка JWT\n(подпись, срок действия)
backend -> backend : 16. Извлечение ролей\nиз JWT (realm_access.roles)
backend -> backend : 17. Авторизация\n(проверка ролей/ scopes)
note right of backend
Примеры проверок в .NET Aspire:
- [Authorize(Roles = "ADMIN")]
- if (User.IsInRole("MODERATOR")) { ... }
- Проверка claims из JWT
end note

== 4. Получение секретов из Vault ==

backend -> vault : 18. Аутентификация в Vault\nчерез Kubernetes Auth\n(POST /v1/auth/kubernetes/login)\n(jwt=<ServiceAccount Token>)
vault -> vault : 19. Проверка JWT\nServiceAccount, поиск Vault Role
vault -> backend : 20. Возврат Vault Token\nограниченного доступа
backend -> vault : 21. Запрос секретов\n(GET /v1/secret/data/myapp/db)\n(X-Vault-Token: <VAULT_TOKEN>)
vault -> backend : 22. Возврат секретов\n(учетные данные БД)

== 5. Доступ к защищенному ресурсу ==

backend -> db : 23. Подключение к БД\nс учетными данными из Vault
db -> backend : 24. Результаты запроса
backend -> frontend : 25. Возврат данных API
frontend -> user : 26. Отображение\nрезультатов пользователю

@enduml
```

**Пояснение:**

Эта диаграмма последовательности (sequence diagram) иллюстрирует сквозной процесс аутентификации и авторизации:

1.  **Аутентификация пользователя (Authorization Code Flow)**:
    *   Пользователь пытается получить доступ к функциональности Frontend.
    *   Frontend перенаправляет пользователя на Keycloak.
    *   Keycloak аутентифицирует пользователя (логин/пароль + опционально MFA).
    *   Пользователь дает согласие на предоставление доступа приложению.
    *   Keycloak возвращает Frontend **Authorization Code**.

2.  **Получение токенов**:
    *   Frontend обменивает **Authorization Code** на токены (ID Token, Access Token, Refresh Token) напрямую с Keycloak.
    *   **Access Token** является **JWT**, содержащим информацию о пользователе, включая его **роли**.

3.  **Авторизация в Backend API**:
    *   Frontend вызывает Backend API, передавая **Access Token (JWT)** в заголовке `Authorization`.
    *   Backend API (используя `AddJwtBearer`) периодически получает **публичный ключ** от Keycloak для проверки подписи JWT.
    *   Backend **проверяет JWT** (подпись, срок действия) и **извлекает роли**.
    *   Приложение выполняет **авторизационную логику**, проверяя наличие необходимых ролей или scopes у пользователя.

4.  **Получение секретов из Vault**:
    *   Backend API, для своей работы (например, подключения к БД), должен получить секреты.
    *   Он **аутентифицируется в Vault** с помощью **Kubernetes ServiceAccount Token** (механизм `kubernetes` auth).
    *   Vault проверяет токен и выдает **Vault Token** с ограниченными правами.
    *   Backend использует Vault Token для **запроса секретов** (например, учетных данных БД).

5.  **Доступ к защищенному ресурсу**:
    *   Backend использует полученные из Vault **учетные данные** для безопасного подключения к **PostgreSQL** и выполнения запросов.
    *   Результаты возвращаются пользователю через Frontend.

Эта схема показывает полный цикл: от входа пользователя в систему до получения защищенных данных из БД, с использованием Keycloak для аутентификации/авторизации и Vault для управления секретами, что соответствует теме "Безопасность и управление доступом".
