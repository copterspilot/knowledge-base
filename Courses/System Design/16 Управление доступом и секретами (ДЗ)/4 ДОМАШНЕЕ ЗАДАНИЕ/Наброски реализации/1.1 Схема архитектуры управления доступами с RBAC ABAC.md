Хорошо, вот схема архитектуры управления доступами с RBAC/ABAC для вашего стека (.NET Aspire, Keycloak, Vault):

```plantuml
@startuml
' Стили
skinparam rectangle {
    roundCorner 10
}
skinparam component {
    roundCorner 10
}

title Схема архитектуры управления доступами (RBAC/ABAC)

' Внешний пользователь
actor "Пользователь\n(USER, ADMIN, MODERATOR)" as user #e1f5fe

' Aspire Application
package "Aspire Application (K8s)" {
    rectangle "Aspire App Host" as aspire_host #e3f2fd {
        rectangle "Frontend App" as frontend #c8e6c9
        rectangle "Backend API" as backend #e8f5e8
    }
}

' Keycloak
package "Keycloak (Auth Server)" as keycloak_pkg #f3e5f5 {
    rectangle "Keycloak Server" as keycloak #e1bee7 {
        rectangle "Пользователи и Роли\n(RBAC)" as rbac #d1c4e9
        rectangle "Ресурсы и Политики\n(ABAC/UMA)" as abac #d1c4e9
        rectangle "Генерация JWT" as jwt_generator #d1c4e9
    }
}

' Vault
package "HashiCorp Vault (Secrets)" as vault_pkg #fff3e0 {
    rectangle "Vault Server" as vault #ffe0b2 {
        rectangle "Политики доступа\n(Vault Policies)" as vault_policies #ffcc80
        rectangle "Роли для K8s Auth\n(Vault Roles)" as vault_roles #ffcc80
    }
}

' PostgreSQL
rectangle "PostgreSQL (Database)" as postgresql #e0f2f1

' Связи
user --> frontend : 1. Использует\n(Frontend App)
frontend --> keycloak : 2. Аутентификация\n(Auth Code Flow)
keycloak --> user : 3. Возвращает\nID Token + Access Token (JWT)
user --> backend : 4. Вызывает API\nс Access Token (JWT)
backend --> keycloak : 5. Проверка JWT\n(публичный ключ)
backend --> vault : 6. Получение секретов\n(аутентификация через K8s SA)
vault --> postgresql : 7. Vault предоставляет\nучетные данные для БД

@enduml
```

```
note right of rbac
RBAC в Keycloak:
- Роли: USER, ADMIN, MODERATOR
- Роли добавляются в JWT
end note

note right of abac
ABAC/UMA в Keycloak:
- Ресурсы (например, "report")
- Политики (например, "только владелец")
- Scope-based permissions
end note

note right of jwt_generator
JWT содержит:
- Стандартные claims (sub, iss, exp...)
- Роли (realm-level, client-level)
- Атрибуты пользователя (если настроены)
end note

note right of vault_policies
Vault Policies:
- Определяют права доступа к путям
- Пример: "path 'secret/data/myapp/db' { capabilities = [\"read\"] }"
end note

note right of vault_roles
Vault K8s Auth Roles:
- Привязывают K8s ServiceAccounts к Vault Policies
- Пример: "bound_service_account_names: ['backend-sa'] -> policy: 'backend-policy'"
end note

note top of backend
.NET Aspire Backend:
- Использует AddJwtBearer для проверки JWT
- Полагается на роли из JWT для авторизации
- Получает секреты (DB creds) из Vault
end note
```

**Пояснение:**

1.  **Пользователь** взаимодействует с **Frontend Application**.
2.  **Frontend** перенаправляет пользователя в **Keycloak** для **аутентификации** (Authorization Code Flow).
3.  **Keycloak** аутентифицирует пользователя и, на основе **RBAC** (роли `USER`, `ADMIN`, `MODERATOR`) и, при необходимости, **ABAC/UMA** (политики доступа к ресурсам), формирует **JWT (Access Token)**. Этот токен содержит информацию о пользователе и его ролях/атрибутах.
4.  Пользователь использует **Frontend**, который делает вызовы в **Backend API**, передавая **JWT**.
5.  **Backend API** (используя `AddJwtBearer`) **проверяет подпись JWT** с помощью публичного ключа Keycloak. Он **доверяет информации внутри JWT** (ролям, атрибутам).
6.  Для получения секретов (например, учетных данных для PostgreSQL) **Backend API** аутентифицируется в **HashiCorp Vault**. Это обычно происходит через **Kubernetes ServiceAccount** (механизм `kubernetes` auth в Vault). Vault проверяет ServiceAccount и, согласно своим **политикам (Policies)** и **ролям (Roles)**, предоставляет необходимые секреты.
7.  **Backend API** использует полученные из Vault **учетные данные** для безопасного подключения к **PostgreSQL**.

Эта схема демонстрирует, как RBAC/ABAC реализуются в Keycloak, как информация о доступе передается через JWT и как система в целом управляет доступом как к API, так и к внутренним секретам (через Vault).