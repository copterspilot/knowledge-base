### **Без HashiCorp Vault**

#### **Как это обычно происходит:**
1.  **Самостоятельное управление ключами:**
    *   Приложение или разработчик **самостоятельно генерирует** ключи шифрования (например, AES-256).
    *   Ключи **хранятся** в конфигурационных файлах, переменных среды, коде или в базе данных **рядом с зашифрованными данными**.
2.  **Шифрование на уровне приложения:**
    *   Приложение использует стандартные криптографические библиотеки (например, `System.Security.Cryptography` в .NET, `crypto` в Node.js) для шифрования/дешифрования данных.
    *   Приложение **само отвечает** за безопасную генерацию, хранение, ротацию и использование ключей.
3.  **Шифрование на уровне инфраструктуры/хранилища:**
    *   Используются встроенные механизмы шифрования хранилищ (например, **Encryption at Rest** в PostgreSQL, MongoDB, или облачных сервисах типа AWS S3 SSE).
    *   Ключи управления этими системами часто **принадлежат провайдеру** или управляются **отдельно** (например, через AWS KMS).

#### **Проблемы и риски:**
*   **Secret Sprawl (Разрастание секретов):** Ключи могут "утекать" в код, логи, конфиги, репозитории.
*   **Сложность управления ключами:** Самостоятельная реализация безопасного хранения, ротации и распространения ключей **очень сложна** и подвержена ошибкам.
*   **Несоответствие принципам System Design:**
    *   **Нарушение принципа единственной ответственности:** Приложение отвечает и за бизнес-логику, и за криптографию.
    *   **Низкая надежность:** Ошибки в самодельных решениях могут привести к компрометации данных.
    *   **Сложное масштабирование:** Управление ключами в распределенной системе без централизованного решения становится хаотичным.
*   **Отсутствие аудита:** Трудно отследить, кто и когда использовал ключи для шифрования.
*   **Риски при ротации:** Ротация ключей требует изменений в коде/конфигурации приложений, что рискованно.

---

### **С HashiCorp Vault**

#### **Как это происходит с Vault:**
1.  **Централизованное управление ключами:**
    *   Vault становится **единым источником истинны** для криптографических ключей.
    *   Ключи **никогда не покидают** Vault в открытом виде.
2.  **Использование Transit Secret Engine:**
    *   Vault предоставляет **сервис шифрования "как услугу"** через **Transit Engine**.
    *   Приложение **не хранит** ключи. Оно аутентифицируется в Vault (например, через `kubernetes` auth) и получает **токен**.
    *   Приложение отправляет **данные для шифрования** в Vault по API.
    *   Vault **шифрует** данные своим ключом и возвращает **зашифрованный текст (ciphertext)**.
    *   Приложение **само** хранит этот зашифрованный текст (например, в своей БД).
    *   Для **расшифровки** приложение снова отправляет зашифрованный текст в Vault.
3.  **Управление доступом:**
    *   Доступ к операциям шифрования в Vault контролируется через **политики**.
    *   Приложение может шифровать, но, например, только администратор может расшифровывать (или наоборот), в зависимости от настроек политики.
4.  **Автоматическая ротация ключей:**
    *   Vault может **автоматически ротировать** ключи шифрования.
    *   Приложение может продолжать **расшифровывать старые данные**, так как Vault хранит предыдущие версии ключей (если настроено).

#### **Преимущества использования Vault:**
*   **Устранение Secret Sprawl:** Ключи централизованно управляются и не хранятся в приложениях.
*   **Соответствие принципам System Design:**
    *   **Разделение ответственности:** Vault отвечает за криптографию, приложение — за бизнес-логику.
    *   **Надежность:** Используются проверенные, централизованные механизмы.
    *   **Масштабируемость:** Легко управлять шифрованием для множества сервисов.
*   **Упрощенное управление ключами:** Vault берет на себя генерацию, хранение, ротацию и аудит.
*   **Аудит:** Все операции шифрования/расшифровки логируются.
*   **Гибкость:** Можно настроить различные политики доступа для разных операций и сервисов.
*   **Безопасность:** Ключи никогда не передаются приложениям, минимизируя риск утечки.

---

| Аспект | Без Vault | С Vault |
| :--- | :--- | :--- |
| **Хранение ключей** | В приложении/конфигах (риск утечки) | Централизованно в Vault (безопасно) |
| **Управление ключами** | Самостоятельно (сложно и рискованно) | Автоматизировано Vault |
| **Ротация ключей** | Требует изменений в приложении | Автоматическая, прозрачная для приложения |
| **Разделение ответственности** | Приложение отвечает за всё | Vault (криптография) + Приложение (бизнес-логика) |
| **Надежность** | Зависит от реализации в каждом приложении | Высокая, за счет специализированного инструмента |
| **Масштабируемость** | Сложно управлять в распределенной системе | Простое централизованное управление |
| **Аудит** | Требует самостоятельной реализации | Встроен в Vault |
| **Сложность интеграции** | Низкая (используются стандартные библиотеки) | Средняя (требуется интеграция с Vault API/Auth) |
| **Безопасность** | Потенциально низкая из-за распространенных ошибок | Высокая, за счет изоляции ключей и политик доступа |

Использование HashiCorp Vault для шифрования данных как сервис (через Transit Engine) позволяет создать более **безопасную, надежную и масштабируемую** архитектуру.