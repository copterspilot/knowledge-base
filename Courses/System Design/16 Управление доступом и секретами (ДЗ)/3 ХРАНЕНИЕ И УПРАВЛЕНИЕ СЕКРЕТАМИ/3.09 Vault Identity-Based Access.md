### **Сценарий:**

1.  У нас есть **два приложения**:
    *   `web-app`: Нужно читать конфигурацию из `secret/data/webapp/config`.
    *   `backend-worker`: Нужно читать учетные данные БД из `secret/data/backend/db` и генерировать временные учетные записи через `database/creds/worker-role`.
2.  У нас есть **два типа пользователей**:
    *   `developer`: Нужно читать (но не изменять) секреты для отладки.
    *   `admin`: Нужно управлять секретами и политиками.
3.  Все это работает в **Kubernetes**.

Мы хотим использовать **Kubernetes Auth Method** и структурировать доступ на основе **ролей Kubernetes** и **политик Vault**.

---

### **Шаг 1: Включить и настроить Kubernetes Auth Method**

```bash
# Включить метод аутентификации
vault auth enable kubernetes

# Настроить метод (указать адрес Kubernetes API, токен, сертификат)
# Обычно это делается автоматически Helm chart'ом или оператором, но вручную:
vault write auth/kubernetes/config \
    kubernetes_host="https://kubernetes.default.svc.cluster.local:443" \
    kubernetes_ca_cert=@"ca.crt" \
    token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)"
```

---

### **Шаг 2: Создать политики Vault**

Создадим файлы политик:

**`webapp-policy.hcl`:**
```hcl
# Политика для web-app
path "secret/data/webapp/config" {
  capabilities = ["read"]
}

# Разрешить обновление личного токена (например, для продления)
path "auth/token/lookup-self" {
  capabilities = ["read"]
}

path "auth/token/renew-self" {
  capabilities = ["update"]
}
```

**`backend-policy.hcl`:**
```hcl
# Политика для backend-worker
path "secret/data/backend/db" {
  capabilities = ["read"]
}

# Доступ к динамическим учетным записям БД
path "database/creds/worker-role" {
  capabilities = ["read"]
}

# Разрешить обновление личного токена
path "auth/token/lookup-self" {
  capabilities = ["read"]
}

path "auth/token/renew-self" {
  capabilities = ["update"]
}
```

**`developer-policy.hcl`:**
```hcl
# Политика для разработчиков
path "secret/data/webapp/*" {
  capabilities = ["read", "list"]
}

path "secret/data/backend/*" {
  capabilities = ["read", "list"]
}

# Доступ к аудиту своих действий
path "sys/audit/*" {
    capabilities = ["read", "list"]
}

# Запрет на изменение секретов
path "secret/data/*" {
  capabilities = ["read", "list"] # Явно ограничиваем
}
```

**`admin-policy.hcl`:**
```hcl
# Административная политика
path "secret/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

path "database/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

# Управление политиками
path "sys/policies/acl/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}

# Управление Auth Methods
path "sys/auth/*" {
  capabilities = ["create", "read", "update", "delete", "sudo"]
}

path "auth/kubernetes/*" {
  capabilities = ["create", "read", "update", "delete", "list", "sudo"]
}

# Аудит
path "sys/audit/*" {
  capabilities = ["create", "read", "update", "delete", "list"]
}
```

**Загрузить политики в Vault:**
```bash
vault policy write webapp-policy webapp-policy.hcl
vault policy write backend-policy backend-policy.hcl
vault policy write developer-policy developer-policy.hcl
vault policy write admin-policy admin-policy.hcl
```

---

### **Шаг 3: Создать роли в Kubernetes Auth Method**

Теперь свяжем Kubernetes ServiceAccounts/Namespaces с Vault политиками.

**`webapp-role`:**
```bash
vault write auth/kubernetes/role/webapp-role \
    bound_service_account_names="web-app-sa" \
    bound_service_account_namespaces="webapp-namespace" \
    policies="webapp-policy" \
    ttl="1h"
```

**`backend-role`:**
```bash
vault write auth/kubernetes/role/backend-role \
    bound_service_account_names="backend-worker-sa" \
    bound_service_account_namespaces="backend-namespace" \
    policies="backend-policy" \
    ttl="1h"
```

**`developer-role`:** (Если аутентификация пользователей через Kubernetes напрямую, например, через `kubectl exec` с определенным SA)
```bash
# Предположим, есть ServiceAccount developer-sa в namespace dev-namespace
vault write auth/kubernetes/role/developer-role \
    bound_service_account_names="developer-sa" \
    bound_service_account_namespaces="dev-namespace" \
    policies="developer-policy" \
    ttl="30m" # Меньший TTL для пользователей
```

**`admin-role`:**
```bash
# Предположим, есть ServiceAccount admin-sa в namespace admin-namespace
vault write auth/kubernetes/role/admin-role \
    bound_service_account_names="admin-sa" \
    bound_service_account_namespaces="admin-namespace" \
    policies="admin-policy" \
    ttl="1h"
```

---

### **Шаг 4: Использование (пример для `backend-worker`)**

1.  Приложение `backend-worker` запущено в Pod'е в namespace `backend-namespace` с ServiceAccount `backend-worker-sa`.
2.  Приложение получает свой **ServiceAccount JWT Token** (обычно монтируется в `/var/run/secrets/kubernetes.io/serviceaccount/token`).
3.  Приложение аутентифицируется в Vault:
    ```bash
    # Пример curl-запроса (в реальности используйте Vault SDK или Vault Agent)
    KUBE_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
    
    VAULT_RESPONSE=$(curl --request POST \
      --data '{"jwt": "'"$KUBE_TOKEN"'", "role": "backend-role"}' \
      http://vault-address:8200/v1/auth/kubernetes/login)
    
    # Извлекаем клиентский токен
    CLIENT_TOKEN=$(echo $VAULT_RESPONSE | jq -r '.auth.client_token')
    ```
4.  Приложение использует полученный `CLIENT_TOKEN` для доступа к секретам:
    ```bash
    # Получить учетные данные БД
    curl --header "X-Vault-Token: $CLIENT_TOKEN" \
         http://vault-address:8200/v1/secret/data/backend/db
    
    # Получить временные учетные данные БД
    curl --header "X-Vault-Token: $CLIENT_TOKEN" \
         http://vault-address:8200/v1/database/creds/worker-role
    ```

---

### **Как это "наводит порядок":**

1.  **Централизация управления доступом:** Все правила доступа к секретам теперь находятся в политиках Vault, а не разбросаны по конфигам приложений.
2.  **Четкое разделение ролей:**
    *   `web-app` может *только* читать свою конфигурацию.
    *   `backend-worker` может *только* читать свои данные и получать временные учетки БД.
    *   `developer` может просматривать, но не изменять секреты.
    *   `admin` имеет полный доступ.
3.  **Привязка к идентичности:** Доступ напрямую привязан к **Kubernetes ServiceAccount** и **Namespace**. Нет способа "подделать" доступ, не имея соответствующего SA.
4.  **Упрощение аудита:** Легко отследить, какой SA (и, следовательно, какая роль/политика) выполнила операцию в логах Vault.
5.  **Автоматическое управление токенами:** Токены выдаются Vault'ом с определенным TTL и могут автоматически обновляться или истекать, уменьшая риск компрометации долгоживущих статических токенов.

Этот подход соответствует лучшим практикам **Identity-Based Access** и помогает создать упорядоченную, безопасную и масштабируемую систему управления секретами.
