## **1. Список актуальных алгоритмов**  
1. **Белади (OPT)**  
2. **Second Chance (Clock)**  
3. **2Q (Two Queues)**  
4. **SLRU (Segmented LRU)**  
5. **TLRU (Time-Aware LRU)**  
6. **LRU-k**  

---

## **2. Определения и сравнение**  

### **1. Белади (OPT — Optimal Page Replacement)**  
**Определение:**  
Теоретически идеальный алгоритм, который вытесняет данные, **которые не понадобятся дольше всего** в будущем.  

**Как работает:**  
- Требует знания будущих запросов (используется только для анализа других алгоритмов).  

**Плюсы:**  
- Максимально возможный hit ratio.  

**Минусы:**  
- Нереализуем на практике (нужно предсказывать будущее).  

**Где используется:**  
- Только в академических исследованиях для сравнения.  

---

### **2. Second Chance (Clock)**  
**Определение:**  
Модификация FIFO, где у каждого элемента есть «бит доступа». Если элемент был использован, он получает «второй шанс».  

**Как работает:**  
1. Элементы хранятся в кольцевом буфере.  
2. При вытеснении:  
   - Если бит доступа = 1 → бит сбрасывается, элемент пропускается.  
   - Если бит доступа = 0 → элемент вытесняется.  

**Плюсы:**  
- Проще LRU, но эффективнее FIFO.  

**Минусы:**  
- Hit ratio ниже, чем у LRU.  

**Пример:**  
- Используется в ОС (например, Linux для кэширования страниц памяти).  

---

### **3. 2Q (Two Queues)**  
**Определение:**  
Комбинирует FIFO и LRU, используя **две очереди**:  
- **A1 (FIFO)**: Новые элементы.  
- **Am (LRU)**: Часто используемые элементы.  

**Как работает:**  
1. Новый элемент попадает в A1.  
2. При повторном доступе перемещается в Am.  
3. Вытеснение происходит из A1.  

**Плюсы:**  
- Защищает «горячие» данные от вытеснения.  
- Эффективнее LRU для скачкообразных нагрузок.  

**Минусы:**  
- Сложнее FIFO/LRU.  

**Где используется:**  
- Базы данных (например, PostgreSQL).  

---

### **4. SLRU (Segmented LRU)**  
**Определение:**  
Разделяет кэш на **2 сегмента**:  
- **Probationary**: Новые элементы.  
- **Protected**: Часто используемые элементы.  

**Как работает:**  
1. Новый элемент попадает в Probationary.  
2. При повторном доступе перемещается в Protected.  
3. Вытеснение происходит из Probationary.  

**Плюсы:**  
- Уменьшает «засорение» кэша «одноразовыми» данными.  

**Минусы:**  
- Требует настройки соотношения сегментов.  

**Пример:**  
- Кэширование в SSD (Alibaba Cloud).  

---

### **5. TLRU (Time-Aware LRU)**  
**Определение:**  
LRU + учёт **времени жизни (TTL)** элемента.  

**Как работает:**  
1. Элементы сортируются по времени последнего доступа.  
2. При вытеснении удаляются сначала «старые» (по TTL), затем по LRU.  

**Плюсы:**  
- Учитывает «свежесть» данных.  

**Минусы:**  
- Дополнительные накладные расходы на учёт TTL.  

**Где используется:**  
- DNS-кэширование, CDN.  

---

### **6. LRU-k**  
**Определение:**  
Улучшенный LRU, учитывающий **последние k обращений** к элементу.  

**Как работает:**  
1. Для каждого элемента хранится история последних k доступов.  
2. Вытесняет элемент с **наибольшим интервалом** между обращениями.  

**Плюсы:**  
- Точнее LRU для long-tail данных.  

**Минусы:**  
- Высокие накладные расходы при k > 2.  

**Пример:**  
- Рекомендательные системы (кэширование топ-N товаров).  

---

## **3. Сравнение алгоритмов**  

| Алгоритм       | Сложность | Hit Ratio | Память | Где используется         |  
|----------------|-----------|-----------|--------|--------------------------|  
| **OPT**        | O(∞)      | Максимальный | —      | Теория                   |  
| **Second Chance** | O(1)   | Средний   | Низкая | ОС, embedded-системы     |  
| **2Q**         | O(1)      | Высокий   | Средняя | СУБД, веб-кэши          |  
| **SLRU**       | O(1)      | Высокий   | Средняя | Облачные хранилища       |  
| **TLRU**       | O(1)      | Средний   | Низкая | CDN, DNS                 |  
| **LRU-2**      | O(n)      | Очень высокий | Высокая | Big Data, рекомендации   |  

---

## **4. Резюме**  
- **Для общего кэширования** → **2Q/SLRU** (баланс скорости и точности).  
- **Для данных с TTL** → **TLRU**.  
- **Для long-tail данных** → **LRU-2**.  
- **Для embedded-систем** → **Second Chance**.  

**Тренды 2024+:**  
- Гибридные алгоритмы (например, **2Q + TLRU**).  
- ML-оптимизация (предсказание вытеснения на основе паттернов).  

---

## **5. Проверочные вопросы**  

### **Вопрос 1**  
**Какой алгоритм вытеснит ключ, который использовали 5 минут назад, но не используют сейчас?**  
- а) FIFO  
- б) **LRU**  
- в) OPT  

**Ответ:** б) *LRU учитывает только время последнего доступа.*  

---

### **Вопрос 2**  
**Почему 2Q лучше FIFO для кэширования БД?**  
- а) FIFO быстрее.  
- б) **2Q отделяет «горячие» данные от «холодных».**  
- в) 2Q проще реализовать.  

**Ответ:** б) *2Q защищает частые запросы от вытеснения.*  

---

### **Вопрос 3**  
**Какой алгоритм ближе всего к идеальному (но нереализуем)?**  
- а) LRU  
- б) **OPT**  
- в) Second Chance  

**Ответ:** б) *OPT требует знания будущего.*  

---

### **Вопрос 4**  
**Что учитывает TLRU, в отличие от LRU?**  
- а) Частоту обращений.  
- б) **Время жизни (TTL) данных.**  
- в) Размер данных.  

**Ответ:** б) *TLRU добавляет учёт «свежести» данных.*  

---

### **Вопрос 5**  
**Какой алгоритм использует две очереди и перемещает данные между ними?**  
- а) **2Q**  
- б) LRU-k  
- в) OPT  

**Ответ:** а) *2Q разделяет данные на «новые» (A1) и «популярные» (Am).*  

---

**Итог:**  
Выбор алгоритма зависит от:  
1. **Типа нагрузки** (read/write, long-tail).  
2. **Ограничений памяти**.  
3. **Требований к задержкам**.  

Оптимальные варианты для production: **2Q, SLRU, LRU-2**.
