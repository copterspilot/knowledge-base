## **1. Определение**  
**Инвалидация кэша** — это процесс принудительного удаления или обновления данных в кэше при их изменении в основном источнике (БД, API, файловой системе).  

**Цель:**  
- Гарантировать, что кэш всегда возвращает **актуальные данные** (избегать «грязного чтения»).  

---

## **2. Когда требуется инвалидация?**  
Ситуации, при которых кэш становится невалидным:  
1. **Изменение данных** (например, пользователь обновил профиль).  
2. **Удаление данных** (статья была удалена из БД).  
3. **Истечение TTL** (времени жизни записи).  
4. **Масштабные обновления** (миграции, сброс настроек).  

---

## **3. Стратегии инвалидации**  

### **1. Ручная инвалидация**  
**Как работает:**  
- Явное удаление ключа при изменении данных.  

**Пример (Python + Redis):**  
```python
def update_user(user_id, new_data):
    # 1. Обновляем БД
    db.execute("UPDATE users SET name = ? WHERE id = ?", new_data, user_id)
    # 2. Инвалидируем кэш
    cache.delete(f"user:{user_id}")  # Удаляем старые данные
```

**Плюсы:**  
- Полный контроль над актуальностью данных.  

**Минусы:**  
- Риск забыть инвалидировать ключ.  

---

### **2. Инвалидация по TTL (Time-To-Live)**  
**Как работает:**  
- Кэш автоматически удаляет данные через заданное время.  

**Пример:**  
```python
# Данные удалятся через 1 час (3600 секунд), даже если не были изменены
cache.set("top_products", data, ttl=3600)
```

**Плюсы:**  
- Простота реализации.  
- Подходит для данных, которые редко меняются (например, «топ-10 товаров»).  

**Минусы:**  
- Возвращает устаревшие данные до истечения TTL.  

---

### **3. Инвалидация через события (Event-Driven)**  
**Как работает:**  
- Система публикует событие об изменении данных (Kafka, RabbitMQ).  
- Кэш-сервис подписывается на события и инвалидирует ключи.  

**Пример:**  
```python
# При обновлении пользователя в БД:
db.execute("UPDATE users SET ...")
kafka.publish("user_updated", {"user_id": 123})  # Уведомляем кэш
```

**Плюсы:**  
- Реальная актуальность данных.  
- Подходит для распределённых систем.  

**Минусы:**  
- Сложность настройки.  

---

### **4. Паттерн «Write-Through»**  
**Как работает:**  
- Все записи сначала идут в кэш, который синхронно обновляет БД.  
- Кэш всегда актуален (не требует отдельной инвалидации).  

**Пример:**  
```python
def update_user(user_id, data):
    # 1. Обновляем кэш и БД атомарно
    cache.set(f"user:{user_id}", data)  # Данные сразу попадают в кэш
    db.execute("UPDATE users SET ...")  # Затем в БД
```

**Плюсы:**  
- Нет «грязного чтения».  

**Минусы:**  
- Высокая задержка записи.  

---

## **4. Проблемы инвалидации**  

### **1. Гонка данных (Race Condition)**  
**Сценарий:**  
1. Клиент А читает данные из БД (версия 1).  
2. Клиент Б обновляет данные (версия 2) и инвалидирует кэш.  
3. Клиент А записывает устаревшие данные (версия 1) в кэш.  

**Решение:**  
- Использовать **оптимистичные блокировки** (версионирование).  

### **2. Каскадная инвалидация**  
**Сценарий:**  
Инвалидация одного ключа требует пересчёта связанных данных (например, «топ-10 пользователей»).  

**Решение:**  
- Ленивое обновление (пересчёт при следующем запросе).  

---

## **5. Проверочные вопросы**  

### **Вопрос 1**  
**Что произойдёт, если не инвалидировать кэш после обновления БД?**  
- а) Данные в кэше станут неактуальными.  
- б) Кэш автоматически обновится.  
- в) Произойдёт сбой сервера.  

**Ответ:** а) *Кэш продолжит возвращать старые данные.*  

---

### **Вопрос 2**  
**Какой метод инвалидации подходит для данных, которые меняются раз в сутки?**  
- а) Ручная инвалидация.  
- б) **TTL = 24 часа.**  
- в) Write-Through.  

**Ответ:** б) *TTL избавляет от ручного управления.*  

---

### **Вопрос 3**  
**Почему Write-Through не используют в high-load системах?**  
- а) **Увеличивает задержку записи.**  
- б) Он не поддерживает Redis.  
- в) Он слишком сложен.  

**Ответ:** а) *Синхронная запись в кэш и БД создаёт bottleneck.*  

---

## **6. Вывод**  
Инвалидация — ключевой механизм для:  
✅ **Согласованности данных** (кэш ≠ БД).  
✅ **Производительности** (актуальные данные в кэше = меньше запросов к БД).  

**Главное правило:**  
- Для **часто меняющихся данных** → ручная инвалидация или события.  
- Для **стабильных данных** → TTL.  

Неверная инвалидация приводит к ошибкам, которые сложно отловить (например, «почему пользователь видит старый профиль?»).